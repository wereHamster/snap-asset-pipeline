module Snap.Assets
  (
    -- * Configuration
    Config(..)
  , Manifest
  , defaultConfig

    -- * The Asset type
  , Asset(..)

    -- * Builders
  , Builder
  , BuilderResult(..)
  , concatBuilder

    -- * Snap handlers
  , snapAssetHandler

    -- * Template helpers
  , assetPath
  , assetUrl

    -- * Tooling support
  , compileAssets

  ) where


import           Data.ByteString.Lazy (ByteString)
import qualified Data.ByteString.Lazy  as L
import qualified Data.ByteString       as S
import qualified Data.ByteString.Char8 as C
import           Data.Digest.Pure.SHA
import qualified Data.Map              as M
import           Data.Maybe
import qualified Data.List             as List
import qualified Data.Text             as T
import qualified Data.Text.Lazy        as LT
import qualified Data.Text.Encoding    as E
import qualified Data.Text.Lazy.Encoding  as LE
import           Data.Text.Template
import           Data.Time.Clock
import           Data.Time.Clock.POSIX

import           Snap.Core

import           Control.Applicative
import           Control.Monad
import           Control.Monad.IO.Class

import           System.Directory
import           System.FilePath.Posix


data Config = Config
    { sourceDirectory :: String
      -- ^ The root path where the assets are kept. Paths you use in the
      --   builders are relative to this root. Most projects will have an
      --   'assets/' directory where all the javascript, css, images are kept.
      --   The asset pipeline reads from that directory and serves those files
      --   to clients.

    , assetDefinitions :: [ Asset ]
      -- ^ The list of all assets that are known and served to clients. It is
      --   used by the snap handler and compiler to generate the files. If you
      --   have the snap handler disabled (eg. when running in production
      --   mode), it's safe to leave this list empty.

    , assetHost :: Snap String
      -- ^ The asset host used to serve the assets. Used by 'assetUrl' and
      --   'assetPath' to generate the urls. Also see 'pathPrefix'. You
      --   generally have two choices:
      --
      --     * Extract the host from the request (default).
      --
      --     * Use a single fixed host (eg. if you want to use a CDN).
      --
      --   The function should return the full authority, including the
      --   leading @\/\/@. Scheme and port are optional.
      --
      --   > "//localhost"         -- Minimal definition.
      --   > "//localhost:8000"    -- Non-standard port.
      --   > "http://localhost"    -- Explicit scheme.

    , pathPrefix :: String
      -- ^ This prefix is added to paths generated by 'assetPath' and
      --   'assetUrl'. Default is @assets@. If you have a dedicated asset
      --   host, you can leave this an empty string. The two most often used
      --   combinations of 'assetHost' and 'pathPrefix' are:
      --
      --
      --   * Using a dedicated asset host (or a CDN).
      --
      --      > config = { assetHost = return "assets.domain.tld", pathPrefix = "" }
      --      >
      --      >   assetUrl   ->  "http://assets.domain.tld/file.js"
      --      >   assetPath  ->  "http://assets.domain.tld/file.js"
      --
      --
      --   * Serving assets from a subdirectory of the same host as your app.
      --
      --      > config = { assetHost = fromRequest, pathPrefix = "/assets" }
      --      >
      --      >   assetUrl   ->  "http://domain.tld/assets/file.js"
      --      >   assetPath  ->  "/assets/file.js"

    , manifest :: Maybe Manifest
      -- ^ If set, asset urls and paths will be fingerprinted using the hashes
      --   stored in the manifest. This is something you'd want to enable when
      --   your application is running in production mode. You can store the
      --   manifest on disk (as YAML, JSON, plain text etc) and load when your
      --   application is starting, or compile it into your app.
    }

defaultConfig :: IO Config
defaultConfig = do
    cwd <- getCurrentDirectory
    return $ Config
        { sourceDirectory  = cwd ++ "/assets/"
        , assetDefinitions = []
        , assetHost        = fromRequest
        , pathPrefix       = "assets"
        , manifest         = Nothing
        }

fromRequest :: Snap String
fromRequest = do
    req <- getRequest

    let host = rqServerName req
    let port = rqServerPort req

    return $ "//" ++ (C.unpack host) ++ optionalPort port

  where

    optionalPort port
        | port == 80 || port == 443 = ""
        | otherwise                 = ":" ++ (show port)


-- | Describes an asset that is served to the clients. Each asset has a name
--   (that is the string that is used in the incoming requests' URL) and
--   a builder which specifies how to build the asset. The contents are
--   basically a ByteString which is sent in the response back to the client.
data Asset = Asset
    { assetName :: String
    , assetBuilder :: Builder
    }


-- | Builds (compiles, generates, ..) the contents of an asset. Runs in the IO
--   monad so you can do file IO etc. The builder should also have access to
--   the Config so it knows where the root is.
type Builder =
       Config        -- ^ Config so the builder knows where the root is
    -> Maybe UTCTime -- ^ The contents of the If-Modified-Since header,
                     --   so the builder can return NotModified if
                     --   appropriate.
    -> IO BuilderResult

-- | The result of a build.
data BuilderResult
    = NotModified
      -- ^ The contents have not been modified since the last request. This is
      --   especially important in development mode where you don't want to be
      --   needlessly rebuilding the assets.

    | Contents ByteString

  deriving Show


-- | Concatenate all files into a single blob.
concatBuilder :: [ FilePath ] -> Builder
concatBuilder files config ifModifiedSince = do
    case ifModifiedSince of
        Nothing -> build
        Just t  -> do
            mtime <- foldM newestModificationTime t paths
            if mtime == t
                then return NotModified
                else build

  where

    root  = sourceDirectory config
    paths = map (root++) files
    build = Contents <$> L.concat <$> mapM L.readFile paths

    newestModificationTime :: UTCTime -> FilePath -> IO UTCTime
    newestModificationTime acc path =
        max acc <$> getModificationTime path


-- | This builder builds the file using browserify. That tool is nice because
--   it automatically traverses all dependencies by scanning JavaScript files
--   and looking for calls to require(...).
browserifyBuilder :: FilePath -> Builder
browserifyBuilder entryPoint _ _ = undefined
    -- spawn the browserify tool to build the javascript file.
    -- System.Process.createProcess "browserify <path>", capture the stdout of
    -- that command and that's what we want to return.



-- In development mode, there is a snap handler which will serve the assets as
-- we have configured them, simply streaming the output from the builder back
-- to the client.

snapAssetHandler :: Config -> Snap ()
snapAssetHandler config = (dir $ C.pack prefix) $ route assetRoutes
  where

    prefix      = pathPrefix config
    assetRoutes = map snapHandler (assetDefinitions config)

    snapHandler :: Asset -> ( S.ByteString, Snap () )
    snapHandler asset = ( C.pack $ assetName asset, assetHandler asset )

    assetHandler :: Asset -> Snap ()
    assetHandler asset = do
        req <- getRequest
        let mbH = getHeader "If-Modified-Since" req
        ifModifiedSince <- case mbH of
            Nothing  -> return Nothing
            (Just s) -> liftIO $ liftM Just $ parseHttpTime s

        result <- liftIO $ (assetBuilder asset) config (toUTCTime ifModifiedSince)
        case result of
            NotModified -> notModified
            Contents x  -> do
                contents <- liftIO $ resolveReferences (noop config) x
                writeLBS contents

    notModified = modifyResponse $ setResponseStatus 304 "Not Modified"
    toUTCTime   = liftM $ posixSecondsToUTCTime . realToFrac


-- Now, in production mode we need to fingerprint the files. Eg. turn
-- "frameworks.js" into "frameworks-908e25f4bf641868d8683022a5b62f54.js".
-- The large hash is the SHA1 of the file contents, so we can set a Expires
-- header far in the future, but still force the client to refetch the file if
-- the contents change (because then the fingerprint changes).
--
-- If you have templates which reference the "frameworks.js" asset, you need
-- to know the files fingerprint before you can generate the html. So in
-- production mode you precompile the assets and generate a manifest, with
-- mapping from asset name -> fingerprint. The template engine will then use
-- this manifest file to insert the correct urls into the templates.

type Manifest = M.Map String String

-- | For each asset, run the builder to generate the contents, then take the
--   SHA1 of that and add to the manifest. Write the generated files into
--   the output directory, using the correct (fingerprinted) name.
--   The idea is then to upload the contents of the output directory to your
--   CDN, so it can be served by fast/dedicated servers.
compileAssets :: Config -> String -> IO Manifest
compileAssets config outputDirectory = do
    createDirectoryIfMissing True outputDirectory
    foldM updateManifest M.empty (assetDefinitions config)

  where

    prefix = pathPrefix config

    updateManifest :: Manifest -> Asset -> IO Manifest
    updateManifest manifest asset = do
        result <- (assetBuilder asset) config Nothing
        case result of
            NotModified -> error "noway"
            Contents contents -> do
                let dir = (outputDirectory ++ "/" ++ prefix)
                createDirectoryIfMissing True dir

                parsedContents <- resolveReferences (fromAssets config) contents
                let fingerprint = fingerprintFromContents parsedContents
                let name = fingerprintedAssetName (assetName asset) fingerprint
                L.writeFile (dir ++ "/" ++ name) parsedContents

                return $ M.insert (assetName asset) fingerprint manifest


-- | The fingerprint is the SHA1 of the asset contents.
fingerprintFromContents :: ByteString -> String
fingerprintFromContents = showDigest . sha1

-- | Build the asset and return its fingerprint.
assetFingerprint :: Config -> Asset -> IO String
assetFingerprint config asset = do
    result <- (assetBuilder asset) config Nothing
    case result of
        NotModified -> error "noway"
        Contents contents -> return $ fingerprintFromContents contents



-- | Split the name into basename + extension ["frameworks", ".js"], insert
--   ["-", fingerprint] in the middle, then join the parts again.
fingerprintedAssetName :: String -> String -> String
fingerprintedAssetName name fingerprint =
    let split = splitExtension name
    in (fst split) ++ "-" ++ fingerprint ++ (snd split)



-- | This function takes the contents of an asset and substitutes asset-path
--   placeholders with the actual paths. The context defines how this
--   substitution is performed.
--
--   The noop context replaces the paths with non-fingerprinted paths, and is
--   used by the snap asset handler when running in develompent mode. The
--   'fromAssets' context replaces the paths with fingerprinted paths and is
--   used when compiling the assets for production mode.
--
--   The templating library used is not really suitable for web content. The
--   dollar sign ($) is used very often in JavaScript files. Furthermore,
--   since the identifiers are restricted to valid Haskell identifiers, we
--   can't use filenames or even paths. E.g. this would be desired by is
--   currently invalid:
--
--   > ${images/background.png}

resolveReferences :: ContextA IO -> ByteString -> IO ByteString
resolveReferences context contents = do

    ret <- substituteA asText context
    return $ LE.encodeUtf8 ret

  where

    asText :: T.Text
    asText = E.decodeUtf8 $ L.toStrict contents

fromAssets :: Config -> ContextA IO
fromAssets config nameAsText = do
    fingerprint <- assetFingerprint config asset
    return $ T.pack $ buildPath (fingerprintedAssetName name fingerprint)

  where

    name   = T.unpack nameAsText
    assets = assetDefinitions config
    asset  = fromJust $ List.find (\x -> assetName x == name) assets
    prefix = pathPrefix config

    buildPath path = "/" ++ prefix ++ "/" ++ path

noop :: Config -> ContextA IO
noop config nameAsText = do
    return $ T.concat [ "/", T.pack (pathPrefix config), "/", nameAsText ]



-- Lastly, it is desired to compress/minify the files in production mode. This
-- can be done either implicitly (detect filename extension and run the
-- correct compressor depending on the file type) or explicitly by
-- enabling/disabling them in the configuration.

minifyJavascript :: Config -> Maybe UTCTime -> BuilderResult -> IO BuilderResult
minifyJavascript config lastModified result =
    case result of
        NotModified       -> return NotModified
        Contents contents -> Contents <$> uglify contents

  where

    uglify :: ByteString -> IO ByteString
    uglify x = undefined
    -- Spawn the 'uglifyjs' commandline utility, feed it the pretty javascript
    -- and capture its output.


assetPath :: Config -> String -> String
assetPath config name =
    case (manifest config) of
        Nothing       -> buildPath name
        Just manifest ->
            case M.lookup name manifest of
                Nothing -> error $ "Asset " ++ name ++ " not in the manifest"
                Just fingerprint -> buildPath (fingerprintedAssetName name fingerprint)

  where

    prefix         = pathPrefix config
    buildPath path = "/" ++ prefix ++ "/" ++ path


-- | Generate the asset url for the asset with the given name. If we have
--   a manifest we fingerprint the name with the hash from the manifest.
assetUrl :: Config -> String -> Snap String
assetUrl config name = do
    host <- assetHost config
    return $ host ++ assetPath config name
